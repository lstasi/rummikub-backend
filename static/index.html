<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummikub Web</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            flex: 1;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .game-setup, .game-board {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .game-setup {
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        input[type="text"], input[type="url"] {
            width: 100%;
            max-width: 300px;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, input[type="url"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .board-area {
            min-height: 300px;
            background: #f8f9fa;
            border: 3px dashed #dee2e6;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
        }

        .board-area.drag-over {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .combination {
            display: inline-flex;
            margin: 10px;
            padding: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-height: 60px;
            align-items: center;
        }

        .tile {
            width: 45px;
            height: 60px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            margin: 2px;
            cursor: move;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 2px solid transparent;
            user-select: none;
        }

        .tile:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .tile.dragging {
            opacity: 0.6;
            transform: rotate(5deg);
        }

        .tile.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.3);
        }

        /* Tile colors */
        .tile.black { background: #2d3748; color: white; }
        .tile.red { background: #e53e3e; color: white; }
        .tile.blue { background: #3182ce; color: white; }
        .tile.orange { background: #dd6b20; color: white; }
        .tile.joker { 
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            font-weight: bold;
        }

        .player-hand {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .hand-tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 80px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }

        .hand-tiles.drag-over {
            border-color: #28a745;
            background: #f0fff4;
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .info-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            text-align: center;
        }

        .current-player {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
        }

        .player-list {
            list-style: none;
        }

        .player-list li {
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .player-list li:last-child {
            border-bottom: none;
        }

        .actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-actions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            pointer-events: auto;
            z-index: 1000;
        }

        .game-actions.dragging {
            pointer-events: none;
        }

        .game-actions button {
            min-width: 120px;
            font-size: 14px;
            padding: 10px 20px;
        }

        .board-container {
            margin-bottom: 100px; /* Make room for fixed buttons */
        }

        .status-message {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .hidden {
            display: none;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2em;
            }

            .tile {
                width: 40px;
                height: 55px;
                font-size: 12px;
            }

            .game-setup, .game-board {
                padding: 20px;
            }

            .actions {
                flex-direction: column;
            }

            button {
                width: 100%;
                margin: 5px 0;
            }

            .game-info {
                grid-template-columns: 1fr;
            }

            .player-blocks {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                padding: 15px;
            }

            .player-block {
                padding: 10px;
                min-height: 60px;
            }

            .game-status {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 15px;
            }

            .game-actions {
                position: relative;
                transform: none;
                left: auto;
                bottom: auto;
                margin-top: 20px;
                flex-direction: column;
                border-radius: 15px;
            }

            .game-actions button {
                margin: 5px 0;
                min-width: auto;
            }

            .board-container {
                margin-bottom: 20px; /* Reduce since buttons are no longer fixed */
            }
        }

        /* Touch-friendly drag indicators */
        @media (hover: none) {
            .tile {
                transform: none;
            }

            .tile:active {
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(0,0,0,0.2);
            }
        }

        /* Magnet effect animation */
        .tile.magnetized {
            animation: magnetPull 0.5s ease-in-out;
        }

        @keyframes magnetPull {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px) scale(1.1); }
            100% { transform: translateY(0); }
        }

        .combination.highlighted {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            animation: glow 1s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
            to { box-shadow: 0 5px 20px rgba(253, 203, 110, 0.5); }
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Player blocks section */
        .player-blocks {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .player-block {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .player-block.active {
            border-color: #48bb78;
            background: #f0fff4;
        }

        .player-block.current-turn {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        .player-block .player-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .player-block .player-tiles-count {
            font-size: 0.9em;
            color: #666;
        }

        .player-block.current-turn .player-tiles-count {
            color: rgba(255, 255, 255, 0.8);
        }

        .player-block.empty {
            opacity: 0.6;
            font-style: italic;
            color: #999;
        }

        /* Game status section */
        .game-status {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .status-item {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .status-item h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: #333;
        }

        .status-item .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        /* Player hand improvements */
        .hand-lines {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .hand-line {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 70px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
            transition: all 0.3s ease;
        }

        .hand-line.drag-over {
            border-color: #28a745;
            background: #f0fff4;
        }

        .hand-line:empty::after {
            content: "Drag tiles here to organize them";
            color: #adb5bd;
            font-style: italic;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üé≤ Rummikub Web</h1>
            <p><a href="/static/rules.html" target="_blank" style="color: white; text-decoration: underline;">üìñ Game Rules</a></p>
        </header>

        <!-- Game Setup Screen -->
        <div id="setup-screen" class="game-setup">
            <h2>Join or Create Game</h2>

            <div class="form-group">
                <label for="player-name">Your Name:</label>
                <input type="text" id="player-name" placeholder="Enter your name" 
                       maxlength="20">
            </div>

            <div class="form-group">
                <label for="invite-code">Game ID (UUID to join existing game):</label>
                <input type="text" id="invite-code" placeholder="a1b2c3d4-e5f6-7890-abcd-ef1234567890" 
                       style="text-transform: none">
            </div>

            <div class="actions">
                <button id="join-game-btn">Join Game</button>
                <button id="create-game-btn">Create New Game</button>
            </div>

            <div id="status-message" class="status-message hidden"></div>
        </div>

        <!-- Login Screen -->
        <div id="login-screen" class="game-setup hidden">
            <h2>üîê Login to Create Game</h2>
            <p style="color: #666; margin-bottom: 20px;">Please provide administrator credentials to create a new game.</p>

            <div class="form-group">
                <label for="admin-username">Username:</label>
                <input type="text" id="admin-username" placeholder="admin" value="admin">
            </div>

            <div class="form-group">
                <label for="admin-password">Password:</label>
                <input type="password" id="admin-password" placeholder="Enter password">
            </div>

            <div class="actions">
                <button id="login-btn">Login</button>
                <button id="cancel-login-btn">Cancel</button>
            </div>

            <div id="login-message" class="status-message hidden"></div>
        </div>

        <!-- Game Configuration Screen -->
        <div id="config-screen" class="game-setup hidden">
            <h2>üéÆ Configure New Game</h2>
            
            <div class="form-group">
                <label for="max-players">Number of Players (2-4):</label>
                <select id="max-players" style="width: 100%; max-width: 300px; padding: 12px; border: 2px solid #e1e5e9; border-radius: 8px; font-size: 16px;">
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4" selected>4 Players</option>
                </select>
            </div>

            <div id="player-names-section">
                <h3>Player Names:</h3>
                <div id="player-names-container">
                    <!-- Player name inputs will be added here dynamically -->
                </div>
            </div>

            <div class="actions">
                <button id="create-configured-game-btn">Create Game</button>
                <button id="cancel-config-btn">Back</button>
            </div>

            <div id="config-message" class="status-message hidden"></div>
        </div>

        <!-- Game Links Screen -->
        <div id="links-screen" class="game-setup hidden">
            <h2>üé≤ Game Created Successfully!</h2>
            <p style="color: #666; margin-bottom: 20px;">Share these links with other players to join the game:</p>

            <div class="form-group">
                <label>Game ID:</label>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 18px; font-weight: bold; text-align: center; margin-bottom: 15px;">
                    <span id="created-game-id"></span>
                </div>
            </div>

            <div class="form-group">
                <label>Player Links:</label>
                <div id="player-links" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <!-- Links will be populated by JavaScript -->
                </div>
            </div>

            <div class="actions">
                <button id="join-created-game-btn">Join This Game</button>
                <button id="create-another-btn">Create Another Game</button>
            </div>

            <div id="links-message" class="status-message hidden"></div>
        </div>

        <!-- Game Board Screen -->
        <div id="game-screen" class="hidden">
            <!-- Player Blocks Section -->
            <div class="player-blocks">
                <div class="player-block" id="player-block-0">
                    <div class="player-name">Player 1</div>
                    <div class="player-tiles-count">0 tiles</div>
                </div>
                <div class="player-block" id="player-block-1">
                    <div class="player-name">Player 2</div>
                    <div class="player-tiles-count">0 tiles</div>
                </div>
                <div class="player-block" id="player-block-2">
                    <div class="player-name">Player 3</div>
                    <div class="player-tiles-count">0 tiles</div>
                </div>
                <div class="player-block" id="player-block-3">
                    <div class="player-name">Player 4</div>
                    <div class="player-tiles-count">0 tiles</div>
                </div>
            </div>

            <!-- Game Status Section -->
            <div class="game-status">
                <div class="status-item">
                    <h3>Tiles in Pool</h3>
                    <div class="value" id="pool-count">-</div>
                </div>
                <div class="status-item">
                    <h3>Current Turn</h3>
                    <div class="value" id="current-player">-</div>
                </div>
            </div>

            <div class="game-board board-container">
                <h3>Game Board</h3>
                <div id="board-area" class="board-area">
                    <div class="loading" id="board-loading">
                        <div class="spinner"></div>
                        Waiting for game to start...
                    </div>
                </div>
            </div>

            <div class="player-hand">
                <h3>Your Tiles (<span id="hand-count">0</span>)</h3>
                <div class="hand-lines">
                    <div id="hand-line-1" class="hand-line" data-line="1"></div>
                    <div id="hand-line-2" class="hand-line" data-line="2"></div>
                    <div id="hand-line-3" class="hand-line" data-line="3"></div>
                </div>
            </div>

            <!-- Game Actions moved below tiles -->
            <div class="game-actions" id="game-actions" style="display: none;">
                <button id="draw-tile-btn" disabled>Draw Tile</button>
                <button id="next-turn-btn" disabled>Next Turn</button>
                <button id="reset-board-btn" disabled>Reset Board</button>
            </div>

            <div id="game-message" class="status-message hidden"></div>
        </div>
    </div>

    <script>
        // Client-side Rules Engine
        class RummikubRulesEngine {
            static isValidCombination(tiles) {
                if (tiles.length < 3) return false;
                return this.isValidGroup(tiles) || this.isValidRun(tiles);
            }

            static isValidGroup(tiles) {
                if (tiles.length > 4) return false;

                const numbers = new Set();
                const colors = new Set();

                for (const tile of tiles) {
                    if (!tile.is_joker) {
                        numbers.add(tile.number);
                        colors.add(tile.color);
                    }
                }

                // All non-joker tiles should have same number and different colors
                return numbers.size <= 1 && colors.size === tiles.filter(t => !t.is_joker).length;
            }

            static isValidRun(tiles) {
                const colors = new Set();
                const numbers = [];

                for (const tile of tiles) {
                    if (!tile.is_joker) {
                        colors.add(tile.color);
                        numbers.push(tile.number);
                    }
                }

                // All non-joker tiles should have same color
                if (colors.size > 1) return false;

                if (numbers.length === 0) return true; // All jokers

                numbers.sort((a, b) => a - b);

                // Check if numbers can form a consecutive sequence
                const minNum = numbers[0];
                const maxNum = numbers[numbers.length - 1];
                const expectedLength = maxNum - minNum + 1;

                return expectedLength <= tiles.length && expectedLength >= 3;
            }

            static getCombinationValue(tiles) {
                return tiles.reduce((sum, tile) => {
                    if (tile.is_joker) {
                        // For now, assume joker value is context-dependent
                        // In a real implementation, we'd need to determine the joker's value
                        return sum + 0; // Will be calculated based on position
                    }
                    return sum + tile.number;
                }, 0);
            }

            static validateInitialMeld(combinations, hasInitialMeld) {
                if (hasInitialMeld) return true;

                const totalValue = combinations.reduce((sum, combo) => 
                    sum + this.getCombinationValue(combo.tiles), 0);
                
                return totalValue >= 30;
            }

            static validateBoardState(combinations) {
                // All combinations on the board must be valid
                return combinations.every(combo => this.isValidCombination(combo.tiles));
            }
        }

        class RummikubGame {
            constructor() {
                // Automatically determine backend URL based on current host
                const protocol = window.location.protocol;
                const hostname = window.location.hostname;
                // Use the current port, fallback to 8090 for localhost or 80 for others if no port specified
                const currentPort = window.location.port;
                const port = currentPort || (hostname === 'localhost' ? '8090' : '80');
                this.baseUrl = `${protocol}//${hostname}:${port}`;
                
                this.gameId = '';
                this.sessionId = '';
                this.playerName = '';
                this.gameState = null;
                this.selectedTiles = new Set(); // Keep for internal use but not for UI
                this.draggedTile = null;
                this.playerNames = ['Player 1', 'Player 2', 'Player 3', 'Player 4'];
                
                // New properties for board state management
                this.currentBoardState = [];
                this.savedBoardState = []; // For reset functionality
                this.pendingTiles = []; // Tiles placed on board but not yet confirmed
                
                // New properties for tile positioning
                this.tilePositions = {}; // Maps tile ID to {line: number, position: number}
                
                this.initializeElements();
                this.attachEventListeners();
                this.loadFromUrlParams();
                this.loadFromStorage();
            }

            initializeElements() {
                // Setup screen elements
                this.setupScreen = document.getElementById('setup-screen');
                this.gameScreen = document.getElementById('game-screen');
                this.playerNameInput = document.getElementById('player-name');
                this.gameIdInput = document.getElementById('invite-code');
                this.joinGameBtn = document.getElementById('join-game-btn');
                this.createGameBtn = document.getElementById('create-game-btn');
                this.statusMessage = document.getElementById('status-message');

                // Login screen elements
                this.loginScreen = document.getElementById('login-screen');
                this.adminUsernameInput = document.getElementById('admin-username');
                this.adminPasswordInput = document.getElementById('admin-password');
                this.loginBtn = document.getElementById('login-btn');
                this.cancelLoginBtn = document.getElementById('cancel-login-btn');
                this.loginMessage = document.getElementById('login-message');

                // Config screen elements
                this.configScreen = document.getElementById('config-screen');
                this.maxPlayersSelect = document.getElementById('max-players');
                this.playerNamesContainer = document.getElementById('player-names-container');
                this.createConfiguredGameBtn = document.getElementById('create-configured-game-btn');
                this.cancelConfigBtn = document.getElementById('cancel-config-btn');
                this.configMessage = document.getElementById('config-message');

                // Links screen elements
                this.linksScreen = document.getElementById('links-screen');
                this.createdGameId = document.getElementById('created-game-id');
                this.playerLinks = document.getElementById('player-links');
                this.joinCreatedGameBtn = document.getElementById('join-created-game-btn');
                this.createAnotherBtn = document.getElementById('create-another-btn');
                this.linksMessage = document.getElementById('links-message');

                // Game screen elements
                this.gameStatus = document.getElementById('game-status');
                this.currentPlayer = document.getElementById('current-player');
                this.currentPlayerCard = document.getElementById('current-player-card');
                this.playersList = document.getElementById('players-list');
                this.poolCount = document.getElementById('pool-count');
                this.boardArea = document.getElementById('board-area');
                this.boardLoading = document.getElementById('board-loading');
                this.handTiles = document.getElementById('hand-tiles');
                this.handCount = document.getElementById('hand-count');
                this.gameMessage = document.getElementById('game-message');
                
                // New player blocks
                this.playerBlocks = [];
                for (let i = 0; i < 4; i++) {
                    this.playerBlocks.push(document.getElementById(`player-block-${i}`));
                }
                
                // New hand lines
                this.handLines = [
                    document.getElementById('hand-line-1'),
                    document.getElementById('hand-line-2'),
                    document.getElementById('hand-line-3')
                ];
                
                // New game action buttons
                this.gameActions = document.getElementById('game-actions');
                this.drawTileBtn = document.getElementById('draw-tile-btn');
                this.nextTurnBtn = document.getElementById('next-turn-btn');
                this.resetBoardBtn = document.getElementById('reset-board-btn');
            }

            attachEventListeners() {
                this.joinGameBtn.addEventListener('click', () => this.joinGame());
                this.createGameBtn.addEventListener('click', () => this.showLoginScreen());
                
                // New game action listeners
                this.drawTileBtn.addEventListener('click', () => this.drawTile());
                this.nextTurnBtn.addEventListener('click', () => this.nextTurn());
                this.resetBoardBtn.addEventListener('click', () => this.resetBoard());

                // Login screen listeners
                this.loginBtn.addEventListener('click', () => this.authenticateAdmin());
                this.cancelLoginBtn.addEventListener('click', () => this.showSetupScreen());

                // Config screen listeners
                this.createConfiguredGameBtn.addEventListener('click', () => this.createGame());
                this.cancelConfigBtn.addEventListener('click', () => this.showSetupScreen());
                this.maxPlayersSelect.addEventListener('change', () => this.updatePlayerNameInputs());

                // Links screen listeners
                this.joinCreatedGameBtn.addEventListener('click', () => this.joinCreatedGame());
                this.createAnotherBtn.addEventListener('click', () => this.showSetupScreen());

                // Drag and drop for board
                this.boardArea.addEventListener('dragover', this.handleDragOver.bind(this));
                this.boardArea.addEventListener('drop', this.handleBoardDrop.bind(this));
                this.boardArea.addEventListener('dragenter', () => this.boardArea.classList.add('drag-over'));
                this.boardArea.addEventListener('dragleave', () => this.boardArea.classList.remove('drag-over'));

                // Drag and drop for hand lines
                this.handLines.forEach((line, index) => {
                    line.addEventListener('dragover', this.handleDragOver.bind(this));
                    line.addEventListener('drop', (e) => this.handleHandLineDrop(e, index + 1));
                    line.addEventListener('dragenter', () => line.classList.add('drag-over'));
                    line.addEventListener('dragleave', () => line.classList.remove('drag-over'));
                });

                // Enter key support
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        if (!this.gameScreen.classList.contains('hidden')) {
                            this.refreshGame();
                        } else if (!this.loginScreen.classList.contains('hidden')) {
                            this.authenticateAdmin();
                        } else if (this.playerNameInput.value && this.gameIdInput.value) {
                            this.joinGame();
                        }
                    }
                    // ESC key to reset board
                    if (e.key === 'Escape' && !this.gameScreen.classList.contains('hidden')) {
                        this.resetBoard();
                    }
                });
            }

            loadFromUrlParams() {
                const urlParams = new URLSearchParams(window.location.search);
                const nameParam = urlParams.get('name');
                const gameIdParam = urlParams.get('gameId') || urlParams.get('game') || urlParams.get('id');
                
                if (nameParam) {
                    this.playerNameInput.value = nameParam;
                    this.playerName = nameParam;
                }
                
                if (gameIdParam) {
                    this.gameIdInput.value = gameIdParam;
                }
                
                // If both parameters are present, automatically join the game
                if (nameParam && gameIdParam) {
                    setTimeout(() => this.joinGame(), 500);
                }
            }

            loadFromStorage() {
                const saved = localStorage.getItem('rummikub-game');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.gameId = data.gameId || '';
                        this.sessionId = data.sessionId || '';
                        this.playerName = data.playerName || '';
                        
                        if (this.playerName && !this.playerNameInput.value) {
                            this.playerNameInput.value = this.playerName;
                        }
                        
                        if (this.gameId && this.sessionId) {
                            this.showGame();
                            this.refreshGame();
                        }
                    } catch (e) {
                        console.warn('Failed to load saved game data:', e);
                    }
                }
            }

            saveToStorage() {
                const data = {
                    gameId: this.gameId,
                    sessionId: this.sessionId,
                    playerName: this.playerName
                };
                localStorage.setItem('rummikub-game', JSON.stringify(data));
            }

            handleGameNotFound() {
                // Clear the stored game session
                localStorage.removeItem('rummikub-game');
                
                // Reset game state
                this.gameId = '';
                this.sessionId = '';
                this.gameState = null;
                this.selectedTiles.clear();
                this.pendingTiles = [];
                
                // Show message and redirect to main page
                this.showMessage('Game no longer exists (server may have restarted). Returning to main page...', 'warning');
                
                setTimeout(() => {
                    this.showSetupScreen();
                }, 3000);
            }

            showMessage(message, type = 'info') {
                let messageEl = this.statusMessage; // default
                
                if (!this.setupScreen.classList.contains('hidden')) {
                    messageEl = this.statusMessage;
                } else if (!this.loginScreen.classList.contains('hidden')) {
                    messageEl = this.loginMessage;
                } else if (!this.configScreen.classList.contains('hidden')) {
                    messageEl = this.configMessage;
                } else if (!this.linksScreen.classList.contains('hidden')) {
                    messageEl = this.linksMessage;
                } else if (!this.gameScreen.classList.contains('hidden')) {
                    messageEl = this.gameMessage;
                }
                
                messageEl.textContent = message;
                messageEl.className = `status-message status-${type}`;
                messageEl.classList.remove('hidden');
                
                if (type === 'success' || type === 'info') {
                    setTimeout(() => messageEl.classList.add('hidden'), 5000);
                }
            }

            showSetupScreen() {
                this.hideAllScreens();
                this.setupScreen.classList.remove('hidden');
            }

            showLoginScreen() {
                this.hideAllScreens();
                this.loginScreen.classList.remove('hidden');
                this.adminPasswordInput.focus();
            }

            showConfigScreen() {
                this.hideAllScreens();
                this.updatePlayerNameInputs();
                this.configScreen.classList.remove('hidden');
            }

            updatePlayerNameInputs() {
                const maxPlayers = parseInt(this.maxPlayersSelect.value);
                const container = this.playerNamesContainer;
                container.innerHTML = '';

                for (let i = 0; i < maxPlayers; i++) {
                    const formGroup = document.createElement('div');
                    formGroup.className = 'form-group';
                    formGroup.innerHTML = `
                        <label for="player-name-${i}">Player ${i + 1} Name:</label>
                        <input type="text" id="player-name-${i}" 
                               value="${this.playerNames[i] || `Player ${i + 1}`}" 
                               maxlength="20" style="width: 100%; max-width: 300px; padding: 12px; border: 2px solid #e1e5e9; border-radius: 8px; font-size: 16px;">
                    `;
                    container.appendChild(formGroup);
                }
            }

            showLinksScreen(gameId) {
                this.hideAllScreens();
                this.linksScreen.classList.remove('hidden');
                this.createdGameId.textContent = gameId;
                this.generatePlayerLinks(gameId);
            }

            showGame() {
                this.hideAllScreens();
                this.gameScreen.classList.remove('hidden');
                this.gameActions.style.display = 'flex'; // Show action buttons
            }

            hideAllScreens() {
                this.setupScreen.classList.add('hidden');
                this.loginScreen.classList.add('hidden');
                this.configScreen.classList.add('hidden');
                this.linksScreen.classList.add('hidden');
                this.gameScreen.classList.add('hidden');
                this.gameActions.style.display = 'none'; // Hide action buttons
            }

            generatePlayerLinks(gameId) {
                const baseUrl = window.location.origin + window.location.pathname;
                this.playerLinks.innerHTML = '';
                
                // Collect player names from the inputs
                const maxPlayers = parseInt(this.maxPlayersSelect.value);
                const playerNames = [];
                for (let i = 0; i < maxPlayers; i++) {
                    const input = document.getElementById(`player-name-${i}`);
                    playerNames.push(input ? input.value.trim() || `Player ${i + 1}` : `Player ${i + 1}`);
                }
                
                playerNames.forEach((name, index) => {
                    const link = `${baseUrl}?name=${encodeURIComponent(name)}&gameId=${gameId}`;
                    const linkDiv = document.createElement('div');
                    linkDiv.style.marginBottom = '10px';
                    linkDiv.innerHTML = `
                        <strong>${name}:</strong><br>
                        <input type="text" readonly value="${link}" 
                               style="width: 100%; padding: 8px; margin-top: 5px; font-size: 12px; border: 1px solid #ddd; border-radius: 4px;"
                               onclick="this.select(); document.execCommand('copy');" 
                               title="Click to copy">
                    `;
                    this.playerLinks.appendChild(linkDiv);
                });
            }

            async authenticateAdmin() {
                const username = this.adminUsernameInput.value.trim();
                const password = this.adminPasswordInput.value.trim();

                if (!username || !password) {
                    this.showMessage('Please enter username and password', 'error');
                    return;
                }

                // For now, just check hardcoded credentials
                // In a real app, this would validate against the server
                if (username === 'admin' && password === 'rummikub2024') {
                    this.showMessage('Login successful!', 'success');
                    setTimeout(() => this.showConfigScreen(), 1000);
                } else {
                    this.showMessage('Invalid credentials', 'error');
                }
            }

            async joinCreatedGame() {
                const gameId = this.createdGameId.textContent;
                this.gameIdInput.value = gameId;
                this.showSetupScreen();
                setTimeout(() => this.joinGame(), 500);
            }

            async createGame() {
                console.log('=== Starting game creation process ===');
                const maxPlayers = parseInt(this.maxPlayersSelect.value);
                console.log(`Creating game for ${maxPlayers} players`);
                
                // Collect player names
                this.playerNames = [];
                for (let i = 0; i < maxPlayers; i++) {
                    const input = document.getElementById(`player-name-${i}`);
                    this.playerNames.push(input ? input.value.trim() || `Player ${i + 1}` : `Player ${i + 1}`);
                }
                console.log('Player names collected:', this.playerNames);

                try {
                    this.showMessage('Creating game...', 'info');
                    console.log('Sending game creation request to server...');

                    const response = await fetch(`${this.baseUrl}/game`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Basic ' + btoa('admin:rummikub2024')
                        },
                        body: JSON.stringify({ 
                            name: 'Admin',  // Default name for API
                            max_players: maxPlayers
                        })
                    });

                    console.log('Response status:', response.status, response.statusText);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('Game creation response:', data);
                    this.gameId = data.game_id;
                    
                    this.showMessage(`Game created successfully!`, 'success');
                    console.log(`=== Game created with ID: ${data.game_id} ===`);
                    
                    // Show the links screen instead of auto-joining
                    setTimeout(() => this.showLinksScreen(data.game_id), 1000);

                } catch (error) {
                    console.error('=== Error creating game ===', error);
                    this.showMessage(`Failed to create game: ${error.message}`, 'error');
                }
            }

            async joinGame() {
                console.log('=== Starting game join process ===');
                this.playerName = this.playerNameInput.value.trim();
                const gameId = this.gameIdInput.value.trim();
                console.log(`Player "${this.playerName}" attempting to join game: ${gameId}`);

                if (!this.playerName || !gameId) {
                    console.warn('Missing required fields for game join');
                    this.showMessage('Please fill all fields', 'error');
                    return;
                }

                try {
                    this.showMessage('Joining game...', 'info');
                    console.log('Sending join request to server...');

                    const response = await fetch(`${this.baseUrl}/game/${gameId}/join`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            player_name: this.playerName
                        })
                    });

                    console.log('Join response status:', response.status, response.statusText);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    this.gameId = gameId;
                    this.sessionId = data.access_token; // New API returns access_token
                    
                    this.saveToStorage();
                    this.showMessage('Successfully joined game!', 'success');
                    
                    setTimeout(() => {
                        this.showGame();
                        this.refreshGame();
                    }, 1000);

                } catch (error) {
                    console.error('Error joining game:', error);
                    this.showMessage(`Failed to join game: ${error.message}`, 'error');
                }
            }

            async refreshGame() {
                if (!this.gameId || !this.sessionId) {
                    this.showMessage('No active game session', 'error');
                    return;
                }

                try {
                    const response = await fetch(
                        `${this.baseUrl}/game/${this.gameId}`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.sessionId}`
                            }
                        }
                    );

                    if (!response.ok) {
                        // Handle specific cases where game no longer exists or token issues
                        if (response.status === 404 || response.status === 400 || response.status === 401) {
                            this.handleGameNotFound();
                            return;
                        }
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    this.gameState = await response.json();
                    this.updateGameUI();

                } catch (error) {
                    console.error('Error refreshing game:', error);
                    // Check if it's a game not found error or auth error
                    if (error.message.includes('404') || error.message.includes('400') || error.message.includes('401') || 
                        error.message.includes('Game not found') || error.message.includes('Token does not match') || 
                        error.message.includes('Invalid token')) {
                        this.handleGameNotFound();
                        return;
                    }
                    this.showMessage(`Failed to refresh game: ${error.message}`, 'error');
                }
            }

            updateGameUI() {
                if (!this.gameState) return;

                // Update current player
                this.currentPlayer.textContent = this.gameState.current_player || 'Waiting...';
                
                // Update player blocks
                this.updatePlayerBlocks();

                // Update pool count
                this.poolCount.textContent = '~' + (106 - (this.gameState.players.length * 14) - 
                    this.gameState.board.reduce((sum, comb) => sum + comb.tiles.length, 0));

                // Update board
                this.updateBoard();

                // Update hand
                this.updateHand();

                // Update action buttons
                const canPlay = this.gameState.can_play;
                this.drawTileBtn.disabled = !canPlay;
                this.nextTurnBtn.disabled = !canPlay || this.pendingTiles.length === 0;
                this.resetBoardBtn.disabled = !canPlay || this.pendingTiles.length === 0;

                // Hide loading
                this.boardLoading.classList.add('hidden');
            }

            updatePlayerBlocks() {
                // Reset all blocks to empty state
                this.playerBlocks.forEach((block, index) => {
                    block.classList.remove('active', 'current-turn');
                    block.classList.add('empty');
                    block.querySelector('.player-name').textContent = `Player ${index + 1}`;
                    block.querySelector('.player-tiles-count').textContent = 'Empty slot';
                });

                // Update with actual player data
                this.gameState.players.forEach((player, index) => {
                    if (index < 4) {
                        const block = this.playerBlocks[index];
                        block.classList.remove('empty');
                        block.classList.add('active');
                        
                        if (player.name === this.gameState.current_player) {
                            block.classList.add('current-turn');
                        }
                        
                        block.querySelector('.player-name').textContent = player.name;
                        block.querySelector('.player-tiles-count').textContent = `${player.tile_count} tiles`;
                    }
                });
            }

            updateBoard() {
                // Clear existing combinations except loading
                const existingCombs = this.boardArea.querySelectorAll('.combination');
                existingCombs.forEach(comb => comb.remove());

                if (!this.gameState.board.length && this.pendingTiles.length === 0) {
                    this.boardArea.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No tiles on board yet</p>';
                    return;
                }

                // Show confirmed combinations from server
                this.gameState.board.forEach(combination => {
                    const combEl = this.createCombinationElement(combination, false);
                    this.boardArea.appendChild(combEl);
                });

                // Show pending combinations (not yet sent to server)
                this.pendingTiles.forEach(combination => {
                    const combEl = this.createCombinationElement(combination, true);
                    this.boardArea.appendChild(combEl);
                });
                
                // Save current state for reset functionality  
                this.savedBoardState = JSON.parse(JSON.stringify(this.gameState.board));
            }

            updateHand() {
                // Clear all hand lines
                this.handLines.forEach(line => line.innerHTML = '');
                this.handCount.textContent = this.gameState.your_tiles.length;

                this.gameState.your_tiles.forEach(tile => {
                    const tileEl = this.createTileElement(tile, true);
                    
                    // Get tile position or default to line 1
                    const position = this.tilePositions[tile.id] || { line: 1, position: 0 };
                    const targetLine = this.handLines[position.line - 1];
                    
                    targetLine.appendChild(tileEl);
                });
            }

            createCombinationElement(combination, isPending = false) {
                const combEl = document.createElement('div');
                combEl.className = 'combination';
                if (isPending) {
                    combEl.classList.add('pending');
                    combEl.style.border = '2px dashed #667eea';
                }
                combEl.dataset.combinationId = combination.id;

                combination.tiles.forEach(tile => {
                    const tileEl = this.createTileElement(tile, false);
                    if (isPending) {
                        // Allow dragging pending tiles back to hand
                        tileEl.draggable = true;
                        tileEl.addEventListener('dragstart', this.handleDragStart.bind(this));
                        tileEl.addEventListener('dragend', this.handleDragEnd.bind(this));
                    }
                    combEl.appendChild(tileEl);
                });

                return combEl;
            }

            createTileElement(tile, isInHand) {
                const tileEl = document.createElement('div');
                tileEl.className = 'tile';
                tileEl.dataset.tileId = tile.id;
                tileEl.draggable = isInHand && this.gameState?.can_play;

                if (tile.is_joker) {
                    tileEl.classList.add('joker');
                    tileEl.textContent = 'J';
                } else {
                    tileEl.classList.add(tile.color);
                    tileEl.textContent = tile.number;
                }

                if (isInHand) {
                    // Only add drag events for hand tiles - no more click selection
                    tileEl.addEventListener('dragstart', this.handleDragStart.bind(this));
                    tileEl.addEventListener('dragend', this.handleDragEnd.bind(this));
                }

                return tileEl;
            }

            toggleTileSelection(tileEl) {
                // This method is no longer used in the new drag-only interface
                // Keeping for backwards compatibility but functionality removed
            }

            handleDragStart(e) {
                this.draggedTile = e.target;
                e.target.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', e.target.dataset.tileId);
                
                // Disable pointer events on game actions during drag
                this.gameActions.classList.add('dragging');
            }

            handleDragEnd(e) {
                e.target.classList.remove('dragging');
                this.draggedTile = null;
                
                // Re-enable pointer events on game actions after drag
                this.gameActions.classList.remove('dragging');
            }

            handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            }

            handleBoardDrop(e) {
                e.preventDefault();
                this.boardArea.classList.remove('drag-over');
                
                const tileId = e.dataTransfer.getData('text/plain');
                if (tileId && this.draggedTile) {
                    // Add magnet effect
                    this.draggedTile.classList.add('magnetized');
                    setTimeout(() => {
                        if (this.draggedTile) {
                            this.draggedTile.classList.remove('magnetized');
                        }
                    }, 500);

                    // Find the tile object
                    const tile = this.gameState.your_tiles.find(t => t.id === tileId);
                    if (tile) {
                        // Create a new single-tile combination or add to existing combination
                        this.addTileToBoard(tile);
                    }
                }
            }

            addTileToBoard(tile) {
                // Check if this tile can be added to an existing pending combination
                const bestCombination = this.findBestCombinationForTile(tile);
                
                if (bestCombination) {
                    // Add tile to existing combination (magnetic behavior)
                    bestCombination.tiles.push(tile);
                    
                    // Show magnetic effect on the combination
                    setTimeout(() => {
                        const combEl = document.querySelector(`[data-combination-id="${bestCombination.id}"]`);
                        if (combEl) {
                            combEl.classList.add('highlighted');
                            setTimeout(() => combEl.classList.remove('highlighted'), 1000);
                        }
                    }, 100);
                    
                    this.showMessage('Tile snapped to combination! ‚ú®', 'success');
                } else {
                    // Create a new single-tile combination
                    const newCombination = {
                        id: 'pending-' + Date.now(),
                        tiles: [tile]
                    };
                    
                    this.pendingTiles.push(newCombination);
                    this.showMessage('Tile placed on board. Use "Next Turn" to confirm or "Reset Board" to undo.', 'info');
                }
                
                // Remove tile from hand DOM completely (it's still in gameState until confirmed)
                const tileEl = document.querySelector(`[data-tile-id="${tile.id}"]`);
                if (tileEl && tileEl.parentElement) {
                    tileEl.remove();
                }
                
                this.updateBoard();
                this.updateButtonStates();
            }
            
            findBestCombinationForTile(newTile) {
                // Check each pending combination to see if the new tile can be added
                for (const combination of this.pendingTiles) {
                    const testTiles = [...combination.tiles, newTile];
                    
                    // Check if adding this tile creates a valid combination
                    if (RummikubRulesEngine.isValidCombination(testTiles)) {
                        return combination;
                    }
                    
                    // Also check if it creates a valid partial combination (2+ tiles that could become valid)
                    if (testTiles.length >= 2 && this.isValidPartialCombination(testTiles)) {
                        return combination;
                    }
                }
                
                return null;
            }
            
            isValidPartialCombination(tiles) {
                // Allow partial combinations that could become valid with more tiles
                if (tiles.length < 2) return false;
                
                // Check if it's a partial run (same color, consecutive or near-consecutive numbers)
                const colors = new Set();
                const numbers = [];
                
                for (const tile of tiles) {
                    if (!tile.is_joker) {
                        colors.add(tile.color);
                        numbers.push(tile.number);
                    }
                }
                
                // Must be same color for runs
                if (colors.size === 1 && numbers.length >= 2) {
                    numbers.sort((a, b) => a - b);
                    const gap = numbers[numbers.length - 1] - numbers[0];
                    // Allow gaps up to the number of tiles (accounting for jokers)
                    if (gap <= tiles.length) return true;
                }
                
                // Check if it's a partial group (same number, different colors)
                const uniqueNumbers = new Set(numbers);
                if (uniqueNumbers.size === 1 && colors.size === tiles.filter(t => !t.is_joker).length) {
                    return true;
                }
                
                return false;
            }

            updateButtonStates() {
                const canPlay = this.gameState?.can_play;
                this.drawTileBtn.disabled = !canPlay || this.pendingTiles.length > 0;
                this.nextTurnBtn.disabled = !canPlay || this.pendingTiles.length === 0;
                this.resetBoardBtn.disabled = !canPlay || this.pendingTiles.length === 0;
            }

            handleHandLineDrop(e, lineNumber) {
                e.preventDefault();
                const line = this.handLines[lineNumber - 1];
                line.classList.remove('drag-over');
                
                const tileId = e.dataTransfer.getData('text/plain');
                if (tileId) {
                    // Update tile position
                    this.tilePositions[tileId] = { line: lineNumber, position: 0 };
                    
                    // If tile was dragged from board back to hand, remove from pending
                    this.removeTileFromBoard(tileId);
                    
                    // Re-render hand to reflect new position
                    this.updateHand();
                }
            }

            handleHandDrop(e) {
                // Redirect to line 1 for backwards compatibility
                this.handleHandLineDrop(e, 1);
            }

            removeTileFromBoard(tileId) {
                // Find and remove tile from pending combinations
                for (let i = this.pendingTiles.length - 1; i >= 0; i--) {
                    const combo = this.pendingTiles[i];
                    const tileIndex = combo.tiles.findIndex(t => t.id === tileId);
                    if (tileIndex !== -1) {
                        combo.tiles.splice(tileIndex, 1);
                        if (combo.tiles.length === 0) {
                            this.pendingTiles.splice(i, 1);
                        }
                        break;
                    }
                }
                
                // The tile will be recreated in the hand by updateHand()
                // No need to manually show/hide - updateHand() recreates all tiles from gameState
                
                this.updateBoard();
                this.updateHand(); // Re-render hand to reflect changes
                this.updateButtonStates();
            }

            async drawTile() {
                if (!this.gameState?.can_play) {
                    this.showMessage('Not your turn!', 'warning');
                    return;
                }

                if (this.pendingTiles.length > 0) {
                    this.showMessage('Please confirm or reset your board changes first!', 'warning');
                    return;
                }

                try {
                    const response = await fetch(
                        `${this.baseUrl}/game/${this.gameId}/action`,
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.sessionId}`
                            },
                            body: JSON.stringify({
                                action_type: 'draw_tile'
                            })
                        }
                    );

                    if (!response.ok) {
                        // Handle specific cases where game no longer exists or token issues
                        if (response.status === 404 || response.status === 400 || response.status === 401) {
                            this.handleGameNotFound();
                            return;
                        }
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    
                    if (result.success) {
                        this.showMessage('Drew a tile! Turn ended.', 'success');
                        this.refreshGame();
                    } else {
                        this.showMessage(result.message, 'error');
                    }

                } catch (error) {
                    console.error('Error drawing tile:', error);
                    // Check if it's a game not found error or auth error
                    if (error.message.includes('404') || error.message.includes('400') || error.message.includes('401') || 
                        error.message.includes('Game not found') || error.message.includes('Token does not match') || 
                        error.message.includes('Invalid token')) {
                        this.handleGameNotFound();
                        return;
                    }
                    this.showMessage(`Failed to draw tile: ${error.message}`, 'error');
                }
            }

            async nextTurn() {
                if (!this.gameState?.can_play) {
                    this.showMessage('Not your turn!', 'warning');
                    return;
                }

                if (this.pendingTiles.length === 0) {
                    this.showMessage('No tiles to place!', 'warning');
                    return;
                }

                // Validate all pending combinations locally
                const allTiles = [];
                for (const combo of this.pendingTiles) {
                    allTiles.push(...combo.tiles);
                    if (!RummikubRulesEngine.isValidCombination(combo.tiles)) {
                        this.showMessage('Invalid combination detected! Please fix or reset.', 'error');
                        return;
                    }
                }

                // Check initial meld requirement if needed
                const player = this.gameState.players.find(p => p.name === this.playerName);
                if (!player?.has_initial_meld) {
                    if (!RummikubRulesEngine.validateInitialMeld(this.pendingTiles, false)) {
                        this.showMessage('Initial meld must be worth at least 30 points!', 'error');
                        return;
                    }
                }

                try {
                    // Send all tiles to place
                    const tileIds = allTiles.map(tile => tile.id);
                    
                    const response = await fetch(
                        `${this.baseUrl}/game/${this.gameId}/action`,
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.sessionId}`
                            },
                            body: JSON.stringify({
                                action_type: 'place_tiles',
                                tiles: tileIds
                            })
                        }
                    );

                    if (!response.ok) {
                        // Handle specific cases where game no longer exists or token issues
                        if (response.status === 404 || response.status === 400 || response.status === 401) {
                            this.handleGameNotFound();
                            return;
                        }
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    
                    if (result.success) {
                        this.showMessage('Turn completed!', 'success');
                        this.pendingTiles = [];
                        this.refreshGame();
                    } else {
                        this.showMessage(result.message, 'error');
                    }

                } catch (error) {
                    console.error('Error completing turn:', error);
                    // Check if it's a game not found error or auth error
                    if (error.message.includes('404') || error.message.includes('400') || error.message.includes('401') || 
                        error.message.includes('Game not found') || error.message.includes('Token does not match') || 
                        error.message.includes('Invalid token')) {
                        this.handleGameNotFound();
                        return;
                    }
                    this.showMessage(`Failed to complete turn: ${error.message}`, 'error');
                }
            }

            resetBoard() {
                if (this.pendingTiles.length === 0) {
                    this.showMessage('No changes to reset!', 'warning');
                    return;
                }

                // Clear all pending tiles
                this.pendingTiles = [];
                
                // Regenerate hand from game state (tiles will be recreated)
                this.updateHand();
                this.updateBoard();
                this.updateButtonStates();
                this.showMessage('Board reset!', 'success');
            }

        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new RummikubGame();
        });
    </script>
</body>
</html>