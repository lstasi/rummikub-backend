<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummikub - Simple Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f6fa;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .game-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .section-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        /* Setup Screen */
        .setup-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #2c3e50;
        }

        input[type="text"], input[type="url"] {
            padding: 12px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            font-size: 16px;
            width: 300px;
        }

        input[type="text"]:focus, input[type="url"]:focus {
            outline: none;
            border-color: #3498db;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin: 5px;
        }

        button:hover {
            background: #2980b9;
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        /* Game Board */
        .game-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .board-area {
            background: #ecf0f1;
            border: 2px dashed #bdc3c7;
            border-radius: 10px;
            min-height: 400px;
            padding: 20px;
        }

        .hand-area {
            background: #ecf0f1;
            border-radius: 10px;
            padding: 20px;
            min-height: 300px;
        }

        .tile {
            display: inline-block;
            width: 45px;
            height: 60px;
            border-radius: 5px;
            margin: 3px;
            text-align: center;
            line-height: 60px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .tile.selected {
            border-color: #e74c3c;
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(231, 76, 60, 0.4);
        }

        .tile.red { background: #e74c3c; color: white; }
        .tile.blue { background: #3498db; color: white; }
        .tile.black { background: #2c3e50; color: white; }
        .tile.orange { background: #f39c12; color: white; }
        .tile.joker { background: #9b59b6; color: white; }

        .combination {
            display: inline-block;
            background: white;
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            margin: 10px;
            padding: 10px;
            min-height: 80px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .combination.selected {
            border-color: #e74c3c;
            background: #fdf2f2;
        }

        .actions-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .status-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-item {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .status-item .label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .status-item .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #2c3e50;
        }

        .message {
            padding: 10px 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: 600;
        }

        .message.success {
            background: #d5f4e6;
            color: #27ae60;
            border: 1px solid #27ae60;
        }

        .message.error {
            background: #faddd9;
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }

        .message.warning {
            background: #fef9e7;
            color: #f39c12;
            border: 1px solid #f39c12;
        }

        .hidden {
            display: none;
        }

        .auto-refresh {
            background: #27ae60;
        }

        .auto-refresh:hover {
            background: #219a52;
        }

        .auto-refresh.active {
            background: #e74c3c;
        }

        .auto-refresh.active:hover {
            background: #c0392b;
        }

        /* Special buttons */
        .primary-btn {
            background: #27ae60;
        }

        .primary-btn:hover {
            background: #219a52;
        }

        .danger-btn {
            background: #e74c3c;
        }

        .danger-btn:hover {
            background: #c0392b;
        }

        .secondary-btn {
            background: #95a5a6;
        }

        .secondary-btn:hover {
            background: #7f8c8d;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ² Rummikub - Simple Interface</h1>
            <p>Select tiles and use action buttons to play</p>
        </div>

        <!-- Setup Screen -->
        <div id="setup-screen" class="game-section">
            <div class="section-title">Join Game</div>
            <div class="setup-form">
                <div class="form-group">
                    <label for="server-url">Server URL:</label>
                    <input type="url" id="server-url" value="http://localhost:8090" />
                </div>
                <div class="form-group">
                    <label for="game-id">Game ID:</label>
                    <input type="text" id="game-id" placeholder="Enter game ID" />
                </div>
                <div class="form-group">
                    <label for="player-name">Player Name:</label>
                    <input type="text" id="player-name" placeholder="Enter your name" />
                </div>
                <button id="join-btn">Join Game</button>
                <div id="setup-message" class="message hidden"></div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden">
            <!-- Game Status -->
            <div class="game-section">
                <div class="section-title">Game Status</div>
                <div class="status-info">
                    <div class="status-item">
                        <div class="label">Current Player</div>
                        <div class="value" id="current-player">-</div>
                    </div>
                    <div class="status-item">
                        <div class="label">Your Turn</div>
                        <div class="value" id="can-play">-</div>
                    </div>
                    <div class="status-item">
                        <div class="label">Hand Size</div>
                        <div class="value" id="hand-size">-</div>
                    </div>
                    <div class="status-item">
                        <div class="label">Pool Tiles</div>
                        <div class="value" id="pool-count">-</div>
                    </div>
                    <div class="status-item">
                        <div class="label">Selected Tiles</div>
                        <div class="value" id="selected-count">0</div>
                    </div>
                </div>
            </div>

            <!-- Game Board and Hand -->
            <div class="game-section">
                <div class="section-title">Game Board</div>
                <div class="game-grid">
                    <div class="board-area" id="board-area">
                        <p style="text-align: center; color: #7f8c8d; margin-top: 180px;">
                            Board combinations will appear here
                        </p>
                    </div>
                    <div>
                        <div class="section-title">Your Hand</div>
                        <div class="hand-area" id="hand-area">
                            <p style="text-align: center; color: #7f8c8d; margin-top: 100px;">
                                Your tiles will appear here
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="game-section">
                <div class="section-title">Game Actions</div>
                <div class="actions-panel">
                    <button id="create-combination-btn" class="primary-btn" disabled>Create Combination</button>
                    <button id="break-combination-btn" class="danger-btn" disabled>Break Combination</button>
                    <button id="place-tiles-btn" class="primary-btn" disabled>Place Selected Tiles</button>
                    <button id="draw-tile-btn">Draw Tile</button>
                    <button id="reset-board-btn" class="secondary-btn">Reset Board</button>
                    <button id="auto-refresh-btn" class="auto-refresh">Auto Refresh: OFF</button>
                </div>
                <div id="game-message" class="message hidden"></div>
            </div>
        </div>
    </div>

    <script>
        class SimpleRummikubGame {
            constructor() {
                this.baseUrl = '';
                this.gameId = '';
                this.sessionId = '';
                this.gameState = null;
                this.selectedTiles = [];
                this.selectedCombinations = [];
                this.pendingTiles = [];
                this.autoRefresh = false;
                this.refreshInterval = null;
                
                this.initializeElements();
                this.setupEventListeners();
            }

            initializeElements() {
                // Setup screen elements
                this.setupScreen = document.getElementById('setup-screen');
                this.gameScreen = document.getElementById('game-screen');
                this.serverUrlInput = document.getElementById('server-url');
                this.gameIdInput = document.getElementById('game-id');
                this.playerNameInput = document.getElementById('player-name');
                this.joinBtn = document.getElementById('join-btn');
                this.setupMessage = document.getElementById('setup-message');

                // Game screen elements
                this.currentPlayerSpan = document.getElementById('current-player');
                this.canPlaySpan = document.getElementById('can-play');
                this.handSizeSpan = document.getElementById('hand-size');
                this.poolCountSpan = document.getElementById('pool-count');
                this.selectedCountSpan = document.getElementById('selected-count');
                this.boardArea = document.getElementById('board-area');
                this.handArea = document.getElementById('hand-area');

                // Action buttons
                this.createCombinationBtn = document.getElementById('create-combination-btn');
                this.breakCombinationBtn = document.getElementById('break-combination-btn');
                this.placeTilesBtn = document.getElementById('place-tiles-btn');
                this.drawTileBtn = document.getElementById('draw-tile-btn');
                this.resetBoardBtn = document.getElementById('reset-board-btn');
                this.autoRefreshBtn = document.getElementById('auto-refresh-btn');
                this.gameMessage = document.getElementById('game-message');
            }

            setupEventListeners() {
                this.joinBtn.addEventListener('click', () => this.joinGame());
                this.createCombinationBtn.addEventListener('click', () => this.createCombination());
                this.breakCombinationBtn.addEventListener('click', () => this.breakCombination());
                this.placeTilesBtn.addEventListener('click', () => this.placeTiles());
                this.drawTileBtn.addEventListener('click', () => this.drawTile());
                this.resetBoardBtn.addEventListener('click', () => this.resetBoard());
                this.autoRefreshBtn.addEventListener('click', () => this.toggleAutoRefresh());

                // Handle Enter key in input fields
                [this.gameIdInput, this.playerNameInput].forEach(input => {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') this.joinGame();
                    });
                });
            }

            showMessage(text, type = 'info', element = null) {
                const messageEl = element || this.gameMessage;
                messageEl.textContent = text;
                messageEl.className = `message ${type}`;
                messageEl.classList.remove('hidden');
                setTimeout(() => messageEl.classList.add('hidden'), 5000);
            }

            async joinGame() {
                const serverUrl = this.serverUrlInput.value.trim();
                const gameId = this.gameIdInput.value.trim();
                const playerName = this.playerNameInput.value.trim();

                if (!serverUrl || !gameId || !playerName) {
                    this.showMessage('Please fill in all fields', 'error', this.setupMessage);
                    return;
                }

                this.baseUrl = serverUrl;
                this.gameId = gameId;

                try {
                    const response = await fetch(`${this.baseUrl}/game/${gameId}/join`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ player_name: playerName })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    this.sessionId = data.access_token;
                    this.gameState = data.game_state;

                    this.showMessage('Successfully joined game!', 'success', this.setupMessage);
                    setTimeout(() => {
                        this.setupScreen.classList.add('hidden');
                        this.gameScreen.classList.remove('hidden');
                        this.updateUI();
                    }, 1000);

                } catch (error) {
                    console.error('Join game error:', error);
                    this.showMessage(`Failed to join game: ${error.message}`, 'error', this.setupMessage);
                }
            }

            async refreshGameState() {
                if (!this.gameId || !this.sessionId) return;

                try {
                    const response = await fetch(`${this.baseUrl}/game/${this.gameId}`, {
                        headers: { 'Authorization': `Bearer ${this.sessionId}` }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    this.gameState = await response.json();
                    this.updateUI();

                } catch (error) {
                    console.error('Refresh error:', error);
                    this.showMessage(`Failed to refresh: ${error.message}`, 'error');
                }
            }

            updateUI() {
                if (!this.gameState) return;

                // Update status
                this.currentPlayerSpan.textContent = this.gameState.current_player || 'Waiting...';
                this.canPlaySpan.textContent = this.gameState.can_play ? 'Yes' : 'No';
                this.handSizeSpan.textContent = this.gameState.your_tiles?.length || 0;
                this.poolCountSpan.textContent = this.calculatePoolCount();
                this.selectedCountSpan.textContent = this.selectedTiles.length;

                // Update hand
                this.updateHand();
                
                // Update board
                this.updateBoard();

                // Update button states
                this.updateButtonStates();
            }

            calculatePoolCount() {
                if (!this.gameState) return '~106';
                const playersCount = this.gameState.players?.length || 0;
                const boardTiles = this.gameState.board?.reduce((sum, comb) => sum + comb.tiles.length, 0) || 0;
                return `~${106 - (playersCount * 14) - boardTiles}`;
            }

            updateHand() {
                if (!this.gameState?.your_tiles) return;

                this.handArea.innerHTML = '';
                this.gameState.your_tiles.forEach(tile => {
                    const tileEl = this.createTileElement(tile, true);
                    this.handArea.appendChild(tileEl);
                });
            }

            updateBoard() {
                if (!this.gameState?.board) return;

                this.boardArea.innerHTML = '';
                
                // Add existing board combinations
                this.gameState.board.forEach(combination => {
                    const combEl = this.createCombinationElement(combination);
                    this.boardArea.appendChild(combEl);
                });

                // Add pending combinations
                this.pendingTiles.forEach(combination => {
                    const combEl = this.createCombinationElement(combination, true);
                    this.boardArea.appendChild(combEl);
                });

                // Show placeholder text only if no combinations at all
                if (this.gameState.board.length === 0 && this.pendingTiles.length === 0) {
                    this.boardArea.innerHTML = '<p style="text-align: center; color: #7f8c8d; margin-top: 180px;">Board combinations will appear here</p>';
                }
            }

            createTileElement(tile, isInHand = false) {
                const tileEl = document.createElement('div');
                tileEl.className = 'tile';
                tileEl.dataset.tileId = tile.id;

                if (tile.is_joker) {
                    tileEl.classList.add('joker');
                    tileEl.textContent = 'J';
                } else {
                    tileEl.classList.add(tile.color);
                    tileEl.textContent = tile.number;
                }

                if (isInHand) {
                    tileEl.addEventListener('click', () => this.toggleTileSelection(tile, tileEl));
                }

                // Check if tile is selected
                if (this.selectedTiles.some(t => t.id === tile.id)) {
                    tileEl.classList.add('selected');
                }

                return tileEl;
            }

            createCombinationElement(combination, isPending = false) {
                const combEl = document.createElement('div');
                combEl.className = 'combination';
                combEl.dataset.combinationId = combination.id || 'pending';
                
                if (isPending) {
                    combEl.style.border = '2px solid #f39c12';
                }

                combination.tiles.forEach(tile => {
                    const tileEl = this.createTileElement(tile, false);
                    combEl.appendChild(tileEl);
                });

                if (!isPending) {
                    combEl.addEventListener('click', () => this.toggleCombinationSelection(combination, combEl));
                }

                return combEl;
            }

            toggleTileSelection(tile, tileEl) {
                const index = this.selectedTiles.findIndex(t => t.id === tile.id);
                
                if (index >= 0) {
                    // Deselect
                    this.selectedTiles.splice(index, 1);
                    tileEl.classList.remove('selected');
                } else {
                    // Select
                    this.selectedTiles.push(tile);
                    tileEl.classList.add('selected');
                }

                this.selectedCountSpan.textContent = this.selectedTiles.length;
                this.updateButtonStates();
            }

            toggleCombinationSelection(combination, combEl) {
                const index = this.selectedCombinations.findIndex(c => c.id === combination.id);
                
                if (index >= 0) {
                    // Deselect
                    this.selectedCombinations.splice(index, 1);
                    combEl.classList.remove('selected');
                } else {
                    // Select
                    this.selectedCombinations.push(combination);
                    combEl.classList.add('selected');
                }

                this.updateButtonStates();
            }

            updateButtonStates() {
                const canPlay = this.gameState?.can_play || false;
                const hasSelectedTiles = this.selectedTiles.length > 0;
                const hasSelectedCombinations = this.selectedCombinations.length > 0;
                const hasEnoughForCombination = this.selectedTiles.length >= 3;

                this.createCombinationBtn.disabled = !canPlay || !hasEnoughForCombination;
                this.breakCombinationBtn.disabled = !canPlay || !hasSelectedCombinations;
                this.placeTilesBtn.disabled = !canPlay || this.pendingTiles.length === 0;
                this.drawTileBtn.disabled = !canPlay;
                this.resetBoardBtn.disabled = this.pendingTiles.length === 0;
            }

            createCombination() {
                if (this.selectedTiles.length < 3) {
                    this.showMessage('Select at least 3 tiles to create a combination', 'warning');
                    return;
                }

                // Create a new pending combination
                const newCombination = {
                    id: 'pending-' + Date.now(),
                    tiles: [...this.selectedTiles]
                };

                this.pendingTiles.push(newCombination);

                // Remove selected tiles from hand
                this.selectedTiles.forEach(selectedTile => {
                    const index = this.gameState.your_tiles.findIndex(tile => tile.id === selectedTile.id);
                    if (index >= 0) {
                        this.gameState.your_tiles.splice(index, 1);
                    }
                });

                // Clear selection
                this.selectedTiles = [];
                
                this.updateUI();
                this.showMessage('Combination created! Use "Place Selected Tiles" to place it on the board.', 'success');
            }

            breakCombination() {
                if (this.selectedCombinations.length === 0) {
                    this.showMessage('Select a combination to break', 'warning');
                    return;
                }

                this.selectedCombinations.forEach(combination => {
                    // Add tiles back to hand
                    combination.tiles.forEach(tile => {
                        this.gameState.your_tiles.push(tile);
                    });

                    // Remove from pending tiles
                    const index = this.pendingTiles.findIndex(p => p.id === combination.id);
                    if (index >= 0) {
                        this.pendingTiles.splice(index, 1);
                    }
                });

                // Clear selection
                this.selectedCombinations = [];
                
                this.updateUI();
                this.showMessage('Combination(s) broken! Tiles returned to your hand.', 'success');
            }

            async placeTiles() {
                if (this.pendingTiles.length === 0) {
                    this.showMessage('No combinations to place', 'warning');
                    return;
                }

                // Get all tile IDs from pending combinations
                const tileIds = [];
                this.pendingTiles.forEach(combo => {
                    combo.tiles.forEach(tile => tileIds.push(tile.id));
                });

                try {
                    const response = await fetch(`${this.baseUrl}/game/${this.gameId}/action`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.sessionId}`
                        },
                        body: JSON.stringify({
                            action_type: 'place_tiles',
                            tiles: tileIds
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (result.success) {
                        this.pendingTiles = [];
                        this.gameState = result.game_state;
                        this.updateUI();
                        this.showMessage('Turn completed successfully!', 'success');
                    } else {
                        this.showMessage(result.message || 'Failed to place tiles', 'error');
                    }

                } catch (error) {
                    console.error('Place tiles error:', error);
                    this.showMessage(`Failed to place tiles: ${error.message}`, 'error');
                }
            }

            async drawTile() {
                if (!this.gameState?.can_play) {
                    this.showMessage('Not your turn!', 'warning');
                    return;
                }

                try {
                    const response = await fetch(`${this.baseUrl}/game/${this.gameId}/action`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.sessionId}`
                        },
                        body: JSON.stringify({ action_type: 'draw_tile' })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (result.success) {
                        this.gameState = result.game_state;
                        this.updateUI();
                        this.showMessage('Drew a tile! Turn ended.', 'success');
                    } else {
                        this.showMessage(result.message || 'Failed to draw tile', 'error');
                    }

                } catch (error) {
                    console.error('Draw tile error:', error);
                    this.showMessage(`Failed to draw tile: ${error.message}`, 'error');
                }
            }

            resetBoard() {
                if (this.pendingTiles.length === 0) {
                    this.showMessage('No changes to reset', 'warning');
                    return;
                }

                // Return all pending tiles to hand
                this.pendingTiles.forEach(combination => {
                    combination.tiles.forEach(tile => {
                        this.gameState.your_tiles.push(tile);
                    });
                });

                // Clear pending tiles and selections
                this.pendingTiles = [];
                this.selectedTiles = [];
                this.selectedCombinations = [];
                
                this.updateUI();
                this.showMessage('Board reset! All pending tiles returned to hand.', 'success');
            }

            toggleAutoRefresh() {
                this.autoRefresh = !this.autoRefresh;
                
                if (this.autoRefresh) {
                    this.autoRefreshBtn.textContent = 'Auto Refresh: ON';
                    this.autoRefreshBtn.classList.add('active');
                    this.refreshInterval = setInterval(() => this.refreshGameState(), 3000);
                    this.showMessage('Auto refresh enabled (every 3 seconds)', 'success');
                } else {
                    this.autoRefreshBtn.textContent = 'Auto Refresh: OFF';
                    this.autoRefreshBtn.classList.remove('active');
                    if (this.refreshInterval) {
                        clearInterval(this.refreshInterval);
                        this.refreshInterval = null;
                    }
                    this.showMessage('Auto refresh disabled', 'warning');
                }
            }
        }

        // Initialize the game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SimpleRummikubGame();
        });
    </script>
</body>
</html>