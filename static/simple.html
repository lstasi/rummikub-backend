<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummikub - Simple Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f6fa;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 15px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.3em;
            margin-bottom: 5px;
        }

        .game-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .section-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        /* Setup Screen */
        .setup-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #2c3e50;
        }

        input[type="text"], input[type="url"], input[type="password"], select {
            padding: 12px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            font-size: 16px;
            width: 300px;
        }

        input[type="text"]:focus, input[type="url"]:focus, input[type="password"]:focus, select:focus {
            outline: none;
            border-color: #3498db;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin: 5px;
        }

        button:hover {
            background: #2980b9;
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        /* Game Board */
        .board-wrapper {
            position: relative;
        }

        .board-top-actions {
            position: absolute;
            top: -35px;
            right: 10px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .game-grid {
            display: grid;
            grid-template-columns: 1fr 50px 300px;
            gap: 10px;
            align-items: start;
        }

        .transfer-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
            align-self: center;
        }

        .board-bottom-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .sort-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .icon-btn {
            min-width: 40px;
            width: 40px;
            height: 40px;
            font-size: 20px;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .board-area {
            background: #ecf0f1;
            border: 2px dashed #bdc3c7;
            border-radius: 10px;
            min-height: 400px;
            padding: 20px;
        }

        .hand-area {
            background: #ecf0f1;
            border-radius: 10px;
            padding: 20px;
            min-height: 300px;
        }

        .tile {
            display: inline-block;
            width: 45px;
            height: 60px;
            border-radius: 5px;
            margin: 3px;
            text-align: center;
            line-height: 60px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .tile.selected {
            border-color: #e74c3c;
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(231, 76, 60, 0.4);
        }

        .tile.red { background: #e74c3c; color: white; }
        .tile.blue { background: #3498db; color: white; }
        .tile.black { background: #2c3e50; color: white; }
        .tile.orange { background: #f39c12; color: white; }
        .tile.joker { background: #9b59b6; color: white; }

        .combination {
            display: inline-block;
            background: white;
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            margin: 10px;
            padding: 10px;
            min-height: 80px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .combination.selected {
            border-color: #e74c3c;
            background: #fdf2f2;
        }

        .actions-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .status-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-item {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .status-item .label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .status-item .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #2c3e50;
        }

        .message {
            padding: 10px 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: 600;
        }

        .message.success {
            background: #d5f4e6;
            color: #27ae60;
            border: 1px solid #27ae60;
        }

        .message.error {
            background: #faddd9;
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }

        .message.warning {
            background: #fef9e7;
            color: #f39c12;
            border: 1px solid #f39c12;
        }

        .hidden {
            display: none;
        }

        .auto-refresh {
            background: #27ae60;
        }

        .auto-refresh:hover {
            background: #219a52;
        }

        .auto-refresh.active {
            background: #e74c3c;
        }

        .auto-refresh.active:hover {
            background: #c0392b;
        }

        /* Special buttons */
        .primary-btn {
            background: #27ae60;
        }

        .primary-btn:hover {
            background: #219a52;
        }

        .danger-btn {
            background: #e74c3c;
        }

        .danger-btn:hover {
            background: #c0392b;
        }

        .secondary-btn {
            background: #95a5a6;
        }

        .secondary-btn:hover {
            background: #7f8c8d;
        }

        .success-btn {
            background: #2ecc71;
            font-weight: bold;
        }

        .success-btn:hover {
            background: #27ae60;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎲 Rummikub - Simple Interface</h1>
            <p>Select tiles and use action buttons to play</p>
        </div>

        <!-- Setup Screen -->
        <div id="setup-screen" class="game-section">
            <div class="section-title">Game Setup</div>
            <div class="setup-form">
                <div class="form-group">
                    <label for="server-url">Server URL:</label>
                    <input type="url" id="server-url" value="http://localhost:8090" />
                </div>
                <div class="form-group">
                    <label for="game-id">Select Existing Game:</label>
                    <select id="game-id-select">
                        <option value="">Loading games...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="game-id">Or Enter Game ID:</label>
                    <input type="text" id="game-id" placeholder="Enter game ID manually" />
                </div>
                <div class="form-group">
                    <label for="player-name">Player Name:</label>
                    <input type="text" id="player-name" placeholder="Auto-assigned (P1, P2, P3, P4)" readonly />
                </div>
                <button id="join-btn">Join Game</button>
                <button id="create-game-btn" class="primary-btn">Create New Game</button>
                <div id="setup-message" class="message hidden"></div>
            </div>
        </div>

        <!-- Login Screen for Game Creation -->
        <div id="login-screen" class="game-section hidden">
            <div class="section-title">Create New Game</div>
            <div class="setup-form">
                <div class="form-group">
                    <label for="max-players">Max Players:</label>
                    <select id="max-players">
                        <option value="2">2 Players</option>
                        <option value="3">3 Players</option>
                        <option value="4" selected>4 Players</option>
                    </select>
                </div>
                <button id="login-btn" class="primary-btn">Create Game</button>
                <button id="cancel-login-btn" class="secondary-btn">Cancel</button>
                <div id="login-message" class="message hidden"></div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden">
            <!-- Game Status -->
            <div class="game-section">
                <div class="section-title">Game Status</div>
                <div class="status-info">
                    <div class="status-item">
                        <div class="label">Current Player</div>
                        <div class="value" id="current-player">-</div>
                    </div>
                    <div class="status-item">
                        <div class="label">Your Turn</div>
                        <div class="value" id="can-play">-</div>
                    </div>
                    <div class="status-item">
                        <div class="label">Hand Size</div>
                        <div class="value" id="hand-size">-</div>
                    </div>
                    <div class="status-item">
                        <div class="label">Pool Tiles</div>
                        <div class="value" id="pool-count">-</div>
                    </div>
                    <div class="status-item">
                        <div class="label">Selected Tiles</div>
                        <div class="value" id="selected-count">0</div>
                    </div>
                </div>
            </div>

            <!-- Game Board and Hand -->
            <div class="game-section">
                <div class="section-title">Game Board</div>
                <div class="board-wrapper">
                    <!-- Board action buttons at top right -->
                    <div class="board-top-actions">
                        <button id="draw-tile-btn" class="icon-btn" title="Draw Tile">↓</button>
                        <button id="next-turn-btn" class="icon-btn success-btn" disabled title="Next Turn">→</button>
                        <button id="reset-board-btn" class="icon-btn secondary-btn" disabled title="Reset Board">↕</button>
                    </div>
                    <div class="game-grid">
                        <div class="board-area" id="board-area">
                            <p style="text-align: center; color: #7f8c8d; margin-top: 180px;">
                                Board combinations will appear here
                            </p>
                        </div>
                        <!-- Push/Remove arrows between board and hand -->
                        <div class="transfer-actions">
                            <button id="push-to-board-btn" class="icon-btn primary-btn" disabled title="Push to Board">←</button>
                            <button id="remove-from-board-btn" class="icon-btn danger-btn" disabled title="Remove from Board">→</button>
                        </div>
                        <div>
                            <div class="section-title">Your Hand</div>
                            <div class="hand-area" id="hand-area">
                                <p style="text-align: center; color: #7f8c8d; margin-top: 100px;">
                                    Your tiles will appear here
                                </p>
                            </div>
                            <!-- Sort buttons below hand -->
                            <div class="sort-actions">
                                <button id="sort-number-btn" class="secondary-btn">Number</button>
                                <button id="sort-color-btn" class="secondary-btn">Color</button>
                            </div>
                        </div>
                    </div>
                    <!-- Break/Group buttons at bottom of board -->
                    <div class="board-bottom-actions">
                        <button id="break-set-btn" class="danger-btn" disabled>Break</button>
                        <button id="combine-tiles-btn" class="primary-btn" disabled>Group</button>
                    </div>
                </div>
                <div id="game-message" class="message hidden"></div>
                <!-- Auto refresh button moved to separate section -->
                <div style="text-align: center; margin-top: 10px;">
                    <button id="auto-refresh-btn" class="auto-refresh">Auto Refresh: OFF</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class SimpleRummikubGame {
            constructor() {
                this.baseUrl = '';
                this.gameId = '';
                this.sessionId = '';
                this.gameState = null;
                this.selectedTiles = [];
                this.selectedCombinations = [];
                this.initialGameState = null; // Store initial state for reset
                this.autoRefresh = false;
                this.refreshInterval = null;
                
                // New state management for local operations
                this.tilesPlacedThisTurn = []; // Track tiles moved to board this turn
                this.pendingBoardState = null; // Track pending board changes
                this.turnStartBoardState = null; // Store board state at turn start
                
                this.initializeElements();
                this.setupEventListeners();
                this.loadGames(); // Load available games into dropdown
            }

            initializeElements() {
                // Setup screen elements
                this.setupScreen = document.getElementById('setup-screen');
                this.loginScreen = document.getElementById('login-screen');
                this.gameScreen = document.getElementById('game-screen');
                this.serverUrlInput = document.getElementById('server-url');
                this.gameIdSelect = document.getElementById('game-id-select');
                this.gameIdInput = document.getElementById('game-id');
                this.playerNameInput = document.getElementById('player-name');
                this.joinBtn = document.getElementById('join-btn');
                this.createGameBtn = document.getElementById('create-game-btn');
                this.setupMessage = document.getElementById('setup-message');

                // Login screen elements (now simplified)
                this.maxPlayersSelect = document.getElementById('max-players');
                this.loginBtn = document.getElementById('login-btn');
                this.cancelLoginBtn = document.getElementById('cancel-login-btn');
                this.loginMessage = document.getElementById('login-message');

                // Game screen elements
                this.currentPlayerSpan = document.getElementById('current-player');
                this.canPlaySpan = document.getElementById('can-play');
                this.handSizeSpan = document.getElementById('hand-size');
                this.poolCountSpan = document.getElementById('pool-count');
                this.selectedCountSpan = document.getElementById('selected-count');
                this.boardArea = document.getElementById('board-area');
                this.handArea = document.getElementById('hand-area');

                // Action buttons
                this.pushToBoardBtn = document.getElementById('push-to-board-btn');
                this.removeFromBoardBtn = document.getElementById('remove-from-board-btn');
                this.combineTilesBtn = document.getElementById('combine-tiles-btn');
                this.breakSetBtn = document.getElementById('break-set-btn');
                this.resetBoardBtn = document.getElementById('reset-board-btn');
                this.drawTileBtn = document.getElementById('draw-tile-btn');
                this.nextTurnBtn = document.getElementById('next-turn-btn');
                this.autoRefreshBtn = document.getElementById('auto-refresh-btn');
                this.sortNumberBtn = document.getElementById('sort-number-btn');
                this.sortColorBtn = document.getElementById('sort-color-btn');
                this.gameMessage = document.getElementById('game-message');
            }

            setupEventListeners() {
                this.joinBtn.addEventListener('click', () => this.joinGame());
                this.createGameBtn.addEventListener('click', () => this.showCreateGameScreen());
                this.loginBtn.addEventListener('click', () => this.createGame());
                this.cancelLoginBtn.addEventListener('click', () => this.showSetupScreen());
                
                this.pushToBoardBtn.addEventListener('click', () => this.pushToBoard());
                this.removeFromBoardBtn.addEventListener('click', () => this.removeFromBoard());
                this.combineTilesBtn.addEventListener('click', () => this.combineTiles());
                this.breakSetBtn.addEventListener('click', () => this.breakSet());
                this.resetBoardBtn.addEventListener('click', () => this.resetBoard());
                this.drawTileBtn.addEventListener('click', () => this.drawTile());
                this.nextTurnBtn.addEventListener('click', () => this.nextTurn());
                this.autoRefreshBtn.addEventListener('click', () => this.toggleAutoRefresh());
                this.sortNumberBtn.addEventListener('click', () => this.sortByNumber());
                this.sortColorBtn.addEventListener('click', () => this.sortByColor());

                // Update game ID input when selection changes
                this.gameIdSelect.addEventListener('change', () => {
                    this.gameIdInput.value = this.gameIdSelect.value;
                });

                // Handle Enter key in input fields
                [this.gameIdInput, this.playerNameInput].forEach(input => {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.joinGame();
                        }
                    });
                });
            }

            showSetupScreen() {
                this.setupScreen.classList.remove('hidden');
                this.loginScreen.classList.add('hidden');
                this.gameScreen.classList.add('hidden');
                this.loadGames(); // Refresh games list
            }

            showCreateGameScreen() {
                this.setupScreen.classList.add('hidden');
                this.loginScreen.classList.remove('hidden');
                this.gameScreen.classList.add('hidden');
            }

            showGameScreen() {
                this.setupScreen.classList.add('hidden');
                this.loginScreen.classList.add('hidden');
                this.gameScreen.classList.remove('hidden');
            }

            async loadGames() {
                try {
                    const serverUrl = this.serverUrlInput.value.trim() || 'http://localhost:8090';
                    const response = await fetch(`${serverUrl}/games`);
                    if (response.ok) {
                        const data = await response.json();
                        this.populateGamesDropdown(data.games);
                    } else {
                        this.gameIdSelect.innerHTML = '<option value="">Failed to load games</option>';
                    }
                } catch (error) {
                    console.error('Error loading games:', error);
                    this.gameIdSelect.innerHTML = '<option value="">Error loading games</option>';
                }
            }

            populateGamesDropdown(games) {
                this.gameIdSelect.innerHTML = '<option value="">-- Select a game --</option>';
                
                if (games.length === 0) {
                    this.gameIdSelect.innerHTML += '<option value="">No games available</option>';
                    return;
                }
                
                games.forEach(game => {
                    const option = document.createElement('option');
                    option.value = game.game_id;
                    option.textContent = `${game.game_id.substring(0, 8)}... (${game.player_count}/${game.max_players} players, ${game.status})`;
                    this.gameIdSelect.appendChild(option);
                });
            }

            showMessage(text, type = 'info', element = null) {
                const messageEl = element || this.gameMessage;
                messageEl.textContent = text;
                messageEl.className = `message ${type}`;
                messageEl.classList.remove('hidden');
                setTimeout(() => messageEl.classList.add('hidden'), 5000);
            }

            async createGame() {
                const serverUrl = this.serverUrlInput.value.trim() || 'http://localhost:8090';
                const maxPlayers = parseInt(this.maxPlayersSelect.value);

                this.baseUrl = serverUrl;

                try {
                    const response = await fetch(`${this.baseUrl}/game`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            max_players: maxPlayers 
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    this.gameId = data.game_id;
                    this.gameIdInput.value = data.game_id;
                    
                    this.showMessage(`Game created! ID: ${data.game_id.substring(0, 8)}...`, 'success', this.loginMessage);
                    
                    setTimeout(() => {
                        this.showSetupScreen();
                        setTimeout(() => this.joinGame(), 500);
                    }, 2000);

                } catch (error) {
                    console.error('Create game error:', error);
                    this.showMessage(`Failed to create game: ${error.message}`, 'error', this.loginMessage);
                }
            }

            async joinGame() {
                const serverUrl = this.serverUrlInput.value.trim() || 'http://localhost:8090';
                const gameId = this.gameIdSelect.value || this.gameIdInput.value.trim();

                if (!gameId) {
                    this.showMessage('Please select a game or enter a game ID', 'error', this.setupMessage);
                    return;
                }

                this.baseUrl = serverUrl;
                this.gameId = gameId;

                try {
                    const response = await fetch(`${this.baseUrl}/game/${gameId}/join`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({}) // Player name will be auto-assigned
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    this.sessionId = data.access_token;
                    this.gameState = data.game_state;
                    this.initialGameState = JSON.parse(JSON.stringify(this.gameState)); // Deep copy for reset
                    
                    // Store initial turn start state
                    this.storeTurnStartState();

                    this.showMessage(`Successfully joined as ${data.player_name}!`, 'success', this.setupMessage);
                    setTimeout(() => {
                        this.showGameScreen();
                        this.updateUI();
                    }, 1000);

                } catch (error) {
                    console.error('Join game error:', error);
                    this.showMessage(`Failed to join game: ${error.message}`, 'error', this.setupMessage);
                }
            }

            async refreshGameState() {
                if (!this.gameId || !this.sessionId) return;

                try {
                    const response = await fetch(`${this.baseUrl}/game/${this.gameId}`, {
                        headers: { 'Authorization': `Bearer ${this.sessionId}` }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    this.gameState = await response.json();
                    
                    // If it's now our turn and we haven't stored turn start state, store it
                    if (this.gameState.can_play && this.tilesPlacedThisTurn.length === 0) {
                        this.storeTurnStartState();
                    }
                    
                    this.updateUI();

                } catch (error) {
                    console.error('Refresh error:', error);
                    this.showMessage(`Failed to refresh: ${error.message}`, 'error');
                }
            }

            updateUI() {
                if (!this.gameState) return;

                // Update status
                this.currentPlayerSpan.textContent = this.gameState.current_player || 'Waiting...';
                this.canPlaySpan.textContent = this.gameState.can_play ? 'Yes' : 'No';
                this.handSizeSpan.textContent = this.gameState && this.gameState.your_tiles ? this.gameState.your_tiles.length : 0;
                this.poolCountSpan.textContent = this.calculatePoolCount();
                this.selectedCountSpan.textContent = this.selectedTiles.length;

                // Update areas
                this.updateHand();
                this.updateBoard();
                this.updateButtonStates();
            }

            calculatePoolCount() {
                if (!this.gameState) return '~106';
                const playersCount = this.gameState && this.gameState.players ? this.gameState.players.length : 0;
                const boardTiles = this.gameState && this.gameState.board ? this.gameState.board.reduce((sum, comb) => sum + comb.tiles.length, 0) : 0;
                return `~${106 - (playersCount * 14) - boardTiles}`;
            }

            updateHand() {
                if (!this.gameState || !this.gameState.your_tiles) return;

                this.handArea.innerHTML = '';
                
                // Show only tiles that are in hand (not moved to board locally)
                const handTiles = this.gameState.your_tiles.filter(tile => 
                    !this.tilesPlacedThisTurn.includes(tile.id)
                );
                
                handTiles.forEach(tile => {
                    tile.location = 'hand'; // Ensure location is set
                    const tileEl = this.createTileElement(tile, 'hand');
                    this.handArea.appendChild(tileEl);
                });
            }

            updateBoard() {
                this.boardArea.innerHTML = '';
                
                // Use pending board state if available, otherwise use server state
                const boardToShow = this.pendingBoardState || (this.gameState && this.gameState.board) || [];
                
                if (boardToShow.length === 0) {
                    this.boardArea.innerHTML = '<p style="text-align: center; color: #7f8c8d; margin-top: 180px;">Board combinations will appear here</p>';
                    return;
                }
                
                boardToShow.forEach(combination => {
                    const combEl = this.createCombinationElement(combination);
                    this.boardArea.appendChild(combEl);
                });
            }

            createTileElement(tile, location = 'hand') {
                const tileEl = document.createElement('div');
                tileEl.className = 'tile';
                tileEl.dataset.tileId = tile.id;
                tileEl.dataset.location = location;

                if (tile.is_joker) {
                    tileEl.classList.add('joker');
                    tileEl.textContent = 'J';
                } else {
                    tileEl.classList.add(tile.color);
                    tileEl.textContent = tile.number;
                }

                tileEl.addEventListener('click', () => this.toggleTileSelection(tile, tileEl, location));

                // Check if tile is selected
                if (this.selectedTiles.some(t => t.id === tile.id)) {
                    tileEl.classList.add('selected');
                }

                return tileEl;
            }

            createCombinationElement(combination) {
                const combEl = document.createElement('div');
                combEl.className = 'combination';
                combEl.dataset.combinationId = combination.id;

                combination.tiles.forEach(tile => {
                    const tileEl = this.createTileElement(tile, 'board');
                    combEl.appendChild(tileEl);
                });

                combEl.addEventListener('click', () => this.toggleCombinationSelection(combination, combEl));

                return combEl;
            }

            toggleTileSelection(tile, tileEl, location) {
                const index = this.selectedTiles.findIndex(t => t.id === tile.id);
                
                if (index >= 0) {
                    // Deselect
                    this.selectedTiles.splice(index, 1);
                    tileEl.classList.remove('selected');
                } else {
                    // Select - only allow selection from hand and board tiles
                    if (location === 'hand' || location === 'board') {
                        this.selectedTiles.push({...tile, location});
                        tileEl.classList.add('selected');
                    }
                }

                this.selectedCountSpan.textContent = this.selectedTiles.length;
                this.updateButtonStates();
            }

            toggleCombinationSelection(combination, combEl) {
                const index = this.selectedCombinations.findIndex(c => c.id === combination.id);
                
                if (index >= 0) {
                    // Deselect
                    this.selectedCombinations.splice(index, 1);
                    combEl.classList.remove('selected');
                } else {
                    // Select
                    this.selectedCombinations.push(combination);
                    combEl.classList.add('selected');
                }

                this.updateButtonStates();
            }

            updateButtonStates() {
                const canPlay = this.gameState && this.gameState.can_play || false;
                const hasSelectedHandTiles = this.selectedTiles.filter(t => t.location === 'hand').length > 0;
                const hasSelectedBoardTiles = this.selectedTiles.filter(t => t.location === 'board').length > 0;
                const hasMinTilesForBoard = this.selectedTiles.filter(t => t.location === 'hand').length >= 3;
                const hasPendingChanges = this.tilesPlacedThisTurn.length > 0;

                // UI-only buttons
                this.pushToBoardBtn.disabled = !canPlay || !hasMinTilesForBoard;
                this.removeFromBoardBtn.disabled = !canPlay || !hasSelectedBoardTiles || this.tilesPlacedThisTurn.length === 0;
                this.combineTilesBtn.disabled = !canPlay || !hasSelectedBoardTiles;
                this.breakSetBtn.disabled = !canPlay || !hasSelectedBoardTiles;
                this.resetBoardBtn.disabled = !canPlay || !hasPendingChanges;
                
                // Server operation buttons
                this.drawTileBtn.disabled = !canPlay || hasPendingChanges; // Can't draw if changes pending
                this.nextTurnBtn.disabled = !canPlay || !hasPendingChanges; // Can only submit if changes made
            }

            storeTurnStartState() {
                if (this.gameState) {
                    this.turnStartBoardState = JSON.parse(JSON.stringify(this.gameState.board));
                    this.tilesPlacedThisTurn = [];
                    this.pendingBoardState = JSON.parse(JSON.stringify(this.gameState.board));
                }
            }

            pushToBoard() {
                const handTiles = this.selectedTiles.filter(t => t.location === 'hand');
                if (handTiles.length < 3) {
                    this.showMessage('Select at least 3 tiles from your hand to place on the board', 'warning');
                    return;
                }

                // Move tiles to board locally (UI only)
                handTiles.forEach(tile => {
                    tile.location = 'board';
                    this.tilesPlacedThisTurn.push(tile.id);
                });

                // Add as a new combination to pending board state
                const newCombination = {
                    id: 'temp-' + Date.now(),
                    tiles: [...handTiles]
                };
                this.pendingBoardState.push(newCombination);

                // Clear selections and update UI
                this.selectedTiles = [];
                this.updateUI();
                this.showMessage(`Pushed ${handTiles.length} tiles to board. Use "Next Turn" to confirm or "Reset Board" to undo.`, 'info');
            }

            removeFromBoard() {
                const boardTiles = this.selectedTiles.filter(t => t.location === 'board');
                if (boardTiles.length === 0) {
                    this.showMessage('Select tiles from the board to remove', 'warning');
                    return;
                }

                // Only allow removing tiles that were placed this turn
                const removableTiles = boardTiles.filter(t => this.tilesPlacedThisTurn.includes(t.id));
                if (removableTiles.length === 0) {
                    this.showMessage('You can only remove tiles that you placed this turn', 'warning');
                    return;
                }

                // Move tiles back to hand locally (UI only)
                removableTiles.forEach(tile => {
                    tile.location = 'hand';
                    const index = this.tilesPlacedThisTurn.indexOf(tile.id);
                    if (index > -1) {
                        this.tilesPlacedThisTurn.splice(index, 1);
                    }
                });

                // Remove tiles from pending board state
                this.pendingBoardState = this.pendingBoardState.map(combination => {
                    return {
                        ...combination,
                        tiles: combination.tiles.filter(t => !removableTiles.some(rt => rt.id === t.id))
                    };
                }).filter(combination => combination.tiles.length > 0);

                // Clear selections and update UI
                this.selectedTiles = [];
                this.updateUI();
                this.showMessage(`Removed ${removableTiles.length} tiles from board back to hand`, 'info');
            }

            combineTiles() {
                const boardTiles = this.selectedTiles.filter(t => t.location === 'board');
                if (boardTiles.length < 2) {
                    this.showMessage('Select at least 2 tiles from the board to combine', 'warning');
                    return;
                }

                // Find combinations that contain the selected tiles
                const affectedCombinations = [];
                const remainingCombinations = [];

                this.pendingBoardState.forEach(combination => {
                    const hasSelectedTile = combination.tiles.some(tile => 
                        boardTiles.some(selected => selected.id === tile.id)
                    );
                    if (hasSelectedTile) {
                        affectedCombinations.push(combination);
                    } else {
                        remainingCombinations.push(combination);
                    }
                });

                // Combine all tiles from affected combinations
                let allTiles = [];
                affectedCombinations.forEach(combination => {
                    allTiles.push(...combination.tiles);
                });

                // Create new combination with all tiles
                const newCombination = {
                    id: 'temp-' + Date.now(),
                    tiles: allTiles
                };

                // Update pending board state
                this.pendingBoardState = [...remainingCombinations, newCombination];

                // Clear selections and update UI
                this.selectedTiles = [];
                this.updateUI();
                this.showMessage(`Combined tiles into a single set of ${allTiles.length} tiles`, 'info');
            }

            breakSet() {
                const boardTiles = this.selectedTiles.filter(t => t.location === 'board');
                if (boardTiles.length === 0) {
                    this.showMessage('Select tiles from a set on the board to break', 'warning');
                    return;
                }

                // Find the combination that contains the selected tiles
                let targetCombination = null;
                this.pendingBoardState.forEach(combination => {
                    const hasSelectedTile = combination.tiles.some(tile => 
                        boardTiles.some(selected => selected.id === tile.id)
                    );
                    if (hasSelectedTile) {
                        targetCombination = combination;
                    }
                });

                if (!targetCombination) {
                    this.showMessage('Could not find the set containing selected tiles', 'error');
                    return;
                }

                // Remove the target combination and create individual tile combinations
                this.pendingBoardState = this.pendingBoardState.filter(c => c.id !== targetCombination.id);

                // Create separate combinations for each tile
                targetCombination.tiles.forEach(tile => {
                    this.pendingBoardState.push({
                        id: 'temp-' + Date.now() + '-' + tile.id,
                        tiles: [tile]
                    });
                });

                // Clear selections and update UI
                this.selectedTiles = [];
                this.updateUI();
                this.showMessage(`Broke set into ${targetCombination.tiles.length} individual tiles`, 'info');
            }

            resetBoard() {
                if (this.tilesPlacedThisTurn.length === 0) {
                    this.showMessage('No changes to reset', 'info');
                    return;
                }

                // Restore tiles placed this turn back to hand
                this.gameState.your_tiles.forEach(tile => {
                    if (this.tilesPlacedThisTurn.includes(tile.id)) {
                        tile.location = 'hand';
                    }
                });

                // Reset pending board state to turn start state
                this.pendingBoardState = JSON.parse(JSON.stringify(this.turnStartBoardState));
                this.tilesPlacedThisTurn = [];

                // Clear selections and update UI
                this.selectedTiles = [];
                this.updateUI();
                this.showMessage('Board reset to turn start state', 'info');
            }

            async nextTurn() {
                if (this.tilesPlacedThisTurn.length === 0) {
                    this.showMessage('No tiles placed this turn', 'warning');
                    return;
                }

                // Local validation: check if board state is consistent
                if (!this.validateBoardState()) {
                    this.showMessage('Invalid board state! Please fix combinations or reset board.', 'error');
                    return;
                }

                // Get all tiles that were placed this turn
                const tileIds = this.tilesPlacedThisTurn;

                try {
                    const response = await fetch(`${this.baseUrl}/game/${this.gameId}/action`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.sessionId}`
                        },
                        body: JSON.stringify({
                            action_type: 'place_tiles',
                            tiles: tileIds
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (result.success) {
                        // Clear turn state and update UI
                        this.tilesPlacedThisTurn = [];
                        this.selectedTiles = [];
                        this.selectedCombinations = [];
                        this.gameState = result.game_state;
                        this.storeTurnStartState(); // Store new turn start state
                        this.updateUI();
                        this.showMessage('Turn completed successfully!', 'success');
                    } else {
                        this.showMessage(result.message || 'Failed to complete turn - server rejected the move', 'error');
                    }

                } catch (error) {
                    console.error('Next turn error:', error);
                    this.showMessage(`Failed to complete turn: ${error.message}`, 'error');
                }
            }

            validateBoardState() {
                // Simple validation: check if all combinations have at least 3 tiles
                // More sophisticated validation could be added here
                return this.pendingBoardState.every(combination => {
                    return combination.tiles.length >= 3 || combination.tiles.length === 1; // Allow single tiles temporarily
                });
            }

            async drawTile() {
                if (!this.gameState || !this.gameState.can_play) {
                    this.showMessage('Not your turn!', 'warning');
                    return;
                }

                try {
                    const response = await fetch(`${this.baseUrl}/game/${this.gameId}/action`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.sessionId}`
                        },
                        body: JSON.stringify({ action_type: 'draw_tile' })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (result.success) {
                        this.gameState = result.game_state;
                        this.updateUI();
                        this.showMessage('Drew a tile! Turn ended.', 'success');
                    } else {
                        this.showMessage(result.message || 'Failed to draw tile', 'error');
                    }

                } catch (error) {
                    console.error('Draw tile error:', error);
                    this.showMessage(`Failed to draw tile: ${error.message}`, 'error');
                }
            }

            toggleAutoRefresh() {
                this.autoRefresh = !this.autoRefresh;
                
                if (this.autoRefresh) {
                    this.autoRefreshBtn.textContent = 'Auto Refresh: ON';
                    this.autoRefreshBtn.classList.add('active');
                    this.refreshInterval = setInterval(() => this.refreshGameState(), 3000);
                    this.showMessage('Auto refresh enabled (every 3 seconds)', 'success');
                } else {
                    this.autoRefreshBtn.textContent = 'Auto Refresh: OFF';
                    this.autoRefreshBtn.classList.remove('active');
                    if (this.refreshInterval) {
                        clearInterval(this.refreshInterval);
                        this.refreshInterval = null;
                    }
                    this.showMessage('Auto refresh disabled', 'warning');
                }
            }

            sortByNumber() {
                if (!this.gameState || !this.gameState.hand) return;
                
                // Sort hand tiles by number
                const sortedTiles = [...this.gameState.hand].sort((a, b) => {
                    if (a.is_joker) return 1;
                    if (b.is_joker) return -1;
                    return a.number - b.number;
                });
                
                this.gameState.hand = sortedTiles;
                this.updateUI();
                this.showMessage('Sorted by number', 'success');
            }

            sortByColor() {
                if (!this.gameState || !this.gameState.hand) return;
                
                // Sort hand tiles by color then number
                const colorOrder = { 'black': 0, 'blue': 1, 'red': 2, 'yellow': 3 };
                const sortedTiles = [...this.gameState.hand].sort((a, b) => {
                    if (a.is_joker) return 1;
                    if (b.is_joker) return -1;
                    if (colorOrder[a.color] !== colorOrder[b.color]) {
                        return colorOrder[a.color] - colorOrder[b.color];
                    }
                    return a.number - b.number;
                });
                
                this.gameState.hand = sortedTiles;
                this.updateUI();
                this.showMessage('Sorted by color', 'success');
            }
        }

        // Initialize the game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SimpleRummikubGame();
        });
    </script>
</body>
</html>